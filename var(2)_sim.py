# -*- coding: utf-8 -*-
"""VAR(2)_Sim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QvCmP6KgcSeJhgEj8dJQAvCMidBhzUK3

**VAR(2) Simulation by Catherine Donner**

Importing packages
"""

import pandas as pd
import numpy as np
import scipy as sp
import matplotlib as mpl
import matplotlib.pyplot as plt
import math
from numpy.polynomial import Polynomial
from scipy.optimize import fsolve

"""Finding alphas using numpy Polynomial (note: only for real roots)"""

np.random.seed(1)

def normalize_poly_coef(list_coef):
    norm_constant = list_coef[0]  
    return list_coef[1:len(list_coef)] / norm_constant 

def initialize_B_matrices(p, d):
    B_matrices = [0]*p
    
    for i in range(p):
        B_matrices[i] = np.zeros((d,d))
        
    return B_matrices

def get_stable_var_coeff(p, d):
    B_matrices = initialize_B_matrices(p, d)
    list_roots = []
    list_poly_coefficients = []

    for i in range(d):
        roots = np.round(np.random.uniform(1.5, 6, p), 2)
        poly_from_roots = Polynomial.fromroots(roots)
        poly_coefficients = poly_from_roots.coef
        list_roots.append(roots)
        list_poly_coefficients.append(normalize_poly_coef(poly_coefficients))

    for diag_index, list_coef in enumerate(list_poly_coefficients):
        for mat_index, coef in enumerate(list_coef):
            B_matrices[mat_index][diag_index, diag_index] = coef 

    for matrix in B_matrices:
        max_entry = np.max(np.abs(matrix))
        for row in range(d):
            for col in range(d):
                if row > col:
                    matrix[row, col] = np.random.uniform(-max_entry, max_entry)
    return B_matrices
    
                
sim_var = get_stable_var_coeff(2, 3)
for mat in sim_var:
    print(mat)

"""Setting parameters"""

N=100 #no. of time instants is N

M=N//2

p=2 # order of the AR(p) process

q=0 # order of the MA(q) process

d=3 # dimension of the process

"""Alpha matrices"""

alpha0=np.identity(d)

alpha1=np.array([[-1/2,0,0],[1/2,-4/5,0],[-1/2,1/3,-1/6]]) 
alpha1

alpha2=np.array([[1/2,0,0],[1/3,1/5,0],[-1/2,1,-1/6]]) 
alpha2

"""Beta matrix"""

beta=np.identity(d)

"""Creating the dataset"""

X=np.zeros((d,N))

xi=np.empty((d,N)) #random variables

for k in range(N):
    for m in range(d):
        xi[m,k]=2*np.random.randint(2)-1

for t in range(N):
    for k in range(d):
        for m in range(d):
            X[k,t]=X[k,t]+beta[k,m]*xi[m,t]
            if t > 0: 
                X[k,t]=X[k,t]-alpha1[k,m]*X[m,t-1]
            if t > 1:
                X[k,t]=X[k,t]-alpha2[k,m]*X[m,t-2]

X_1 = np.array([X[0,i] for i in range(N)])
X_2 = np.array([X[1,i] for i in range(N)])
X_3 = np.array([X[2,i] for i in range(N)])

len(X_3)

"""Dataframe for VAR(2) process"""

df = pd.DataFrame([X_1, X_2, X_3]).T
n,d = df.shape # X is an n x d dataframe (can be turned into matrix)

df

"""Finding the covariance matrices"""

def get_Cp(mat, p):
  # t is the total # of time steps, and p for # of variables.
  Xbar = np.zeros(d)
  for i in range(d):
    Xbar[i] = np.mean(mat[: , i])

  C = np.zeros((d, d))
  for i in range(n-p):
    Z0 = np.transpose(mat[i, :] - Xbar) # column vector
    Z1 = mat[i+p, :] - Xbar # row vector
    C = C + np.matmul(Z0, Z1)

  C = C/n
  return C

"""Listed covariance matrices"""

#N=500, identity beta
get_Cp(np.matrix(df), 0)

get_Cp(np.matrix(df), 1)

get_Cp(np.matrix(df), 2)

#N=100, identity beta
get_Cp(np.matrix(df), 0)

get_Cp(np.matrix(df), 1)

get_Cp(np.matrix(df), 2)

"""A and B matrices (NOTE: used scaled beta 0.1*I)"""

A = [[1.        , 0.46748276, 0.14387656],
        [0.        , 1.        , 0.32072719],
        [0.        , 0.        , 1.        ]]
B1 = [[ -0.24773594,  -0.59763715,  -0.30102107],
        [  2.13107939,  -1.59819604,  -0.98338229],
        [ -3.3436938 ,  13.70406716, -14.86824138]]
         
B2 =  [[ -0.24097638, 0.20900861,   0.21845532],
      [  -2.5260206 , 0.13203703,   0.65017662],
      [ 20.03812456, -23.0247509 ,   7.76852381]]
A_inv = np.linalg.inv(A)

"""Estimated alphas using A_inv**B (NOTE: used scaled beta 0.1**I) """

np.matmul(A_inv, B1)

np.matmul(A_inv, B2)

"""MSE and relative errors"""

difference_array1 = np.subtract(np.matmul(A_inv,B1), alpha1)
squared_array1 = np.square(difference_array1)
mse1 = squared_array1.mean()

print(mse1)

difference_array2 = np.subtract(np.matmul(A_inv,B2), alpha2)
squared_array2 = np.square(difference_array2)
mse2 = squared_array2.mean()

print(mse2)

difference_array3 = np.subtract(np.matmul(A_inv,Delta,A_inv.T), np.matmul(beta,beta.T))
squared_array3 = np.square(difference_array3)
re = squared_array3.mean()

print(re)

"""Graph of VAR(2) process"""

# this is using an identity beta matrix
X_1 = np.array([X[0,i] for i in range(N)])
X_2 = np.array([X[1,i] for i in range(N)])
X_3 = np.array([X[2,i] for i in range(N)])

fig, axs = plt.subplots(1,1,figsize=(12,12)) # Create a figure and an axes. 
ax1=plt.subplot(3,2,(1,2))
ax1.plot(range(N),X_1,**{'marker': 'x'},label='$X^1_t$')
ax1.plot(range(N),X_2,**{'marker': 'o'},label='$X^2_t$')
ax1.plot(range(N),X_3,**{'marker': '*'},label='$X^3_t$')

ax1.set_xlabel('Time $t$') # Add an x-label to the axes. 
ax1.set_ylabel('Process $\mathbf{X}_t$') # Add a y-label to the axes. 
ax1.set_title("VAR($p$) process") # Add a title to the axes.

"""Exporting dataframe to Excel file"""

df = pd.DataFrame([X_1, X_2, X_3]).T
df.to_excel('VAR2Simulation.xlsx', index=False)
#df.to_excel(excel_writer = 'C:/Users/1vspe/Documents/VAR1Simulation.xlsx')
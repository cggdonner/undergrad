# -*- coding: utf-8 -*-
"""VAR_higher_order (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SDBWqbPR0KkrVLVTdxGLjVUayKAPBfDK
"""

# Higher order VAR process (p>2)

import pandas as pd
import numpy as np
from numpy.polynomial import Polynomial
from scipy.optimize import fsolve 
import matplotlib as mpl
import matplotlib.pyplot as plt
import math

"""## Generating Stable VAR process coefficients"""

np.random.seed(1)

def normalize_poly_coef(list_coef):
    norm_constant = list_coef[0]  
    return list_coef[1:len(list_coef)] / norm_constant 

def initialize_B_matrices(p, d):
    B_matrices = [0]*p
    
    for i in range(p):
        B_matrices[i] = np.zeros((d,d))
        
    return B_matrices

def get_stable_var_coeff(p, d):
    B_matrices = initialize_B_matrices(p, d)
    list_roots = []
    list_poly_coefficients = []

    for i in range(d):
        roots = np.round(np.random.uniform(1.5, 6, p), 2)
        poly_from_roots = Polynomial.fromroots(roots)
        poly_coefficients = poly_from_roots.coef
        list_roots.append(roots)
        list_poly_coefficients.append(normalize_poly_coef(poly_coefficients))

    for diag_index, list_coef in enumerate(list_poly_coefficients):
        for mat_index, coef in enumerate(list_coef):
            B_matrices[mat_index][diag_index, diag_index] = coef 

    for matrix in B_matrices:
        max_entry = np.max(np.abs(matrix))
        for row in range(d):
            for col in range(d):
                if row > col:
                    matrix[row, col] = np.random.uniform(-max_entry, max_entry)
    return B_matrices
    
                
sim_var = get_stable_var_coeff(3, 5)
for mat in sim_var:
    print(mat)

"""### Results of VAR(3) simulation"""

N=500
M=N//2
p=3
q=0
d=5

# all should be d*d matrices
alpha0=np.identity(d)
alpha1=np.array([[-1/2,0,0,0,0],[1/2,-4/5,0,0,0],[-1/2,1/3,-1/6,0,0],[1/4,-2/5,1/6,1/8,0],[2/3,4/5,-1/6,-1/2,1/3]]) 
alpha2=np.array([[1/2,0,0,0,0],[1/3,1/5,0,0,0],[-1/2,1/3,-1/6,0,0],[-1/3,1/3,1/4,1/5,0],[1/7,2/5,-3/4,5/6,-1/8]]) 
alpha3=np.array([[-1/4,0,0,0,0],[1/5,1/3,0,0,0],[-1/4,1/6,-1/8,0,0],[-1/4,1/4,1/2,3/5,0],[1/6,4/5,-1/4,2/3,-1/5]])

alpha1

alpha2

alpha3

B_3 = np.matrix([[-0.0733142 , -0.04427871,  0.07037913, -0.07460124, -0.00502633],
        [ 0.12396508, -0.13454244,  0.10106068, -0.04477582,  0.00903946],
        [-0.00767939, -0.02834785,  0.0455134 ,  0.00340009, -0.006084  ],
        [-0.07383476,  0.0321499 ,  0.02482108,  0.02230358,  0.01594536],
        [-0.02155194,  0.01172171, -0.07744071, -0.03316097,  0.02298261]])

A = np.matrix([[ 1.00000000e+00,  6.41648805e-02, -3.13603640e-04,
         -2.04484008e-02, -5.69222131e-03],
        [ 0.00000000e+00,  1.00000000e+00, -4.75197982e-02,
          4.23469424e-02,  3.59017563e-02],
        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,
         -1.76514969e-02,  1.02435310e-03],
        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
          1.00000000e+00, -8.56181214e-03],
        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
          0.00000000e+00,  1.00000000e+00]])

B_1 = np.matrix([[-0.47106661, -0.01017666,  0.05181576, -0.04533049, -0.06420134],
        [ 0.6070477 , -0.76578363, -0.04337265, -0.06771858, -0.04960008],
        [-0.5192199 ,  0.3126595 , -0.1437084 , -0.02688171, -0.04741594],
        [ 0.22439119, -0.45887527,  0.19939893,  0.24965253,  0.0026334 ],
        [ 0.72313849,  0.75733256, -0.22582697, -0.51374799,  0.33622541]])

A_inv_B1 = np.matmul(np.linalg.inv(A), B_1)

A_inv_B3 = np.matmul(np.linalg.inv(A), B_3)

display(A_inv_B3)
display(alpha3)

(0.08313091 - .25)/.25 * 100 # percent error
(-0.08313091 - (-0.25))**2 # MSE

display(A_inv_B1)
display(alpha1)

np.sum((A_inv_B - alpha3)**2)

A_inv_B3 = np.matmul(np.linalg.inv(A), B_1)

np.sum(np.abs(A_inv_B - alpha3))

beta=np.identity(d)

X=np.zeros((d,N)) 
xi=np.empty((d,N))

for k in range(N):
    for m in range(d):
        xi[m,k]=2*np.random.randint(2)-1

for t in range(N):
    for k in range(d):
        for m in range(d):
            X[k,t]=X[k,t]+beta[k,m]*xi[m,t]
            if t > 0: 
                X[k,t]=X[k,t]-alpha1[k,m]*X[m,t-1]
            if t > 1:
                X[k,t]=X[k,t]-alpha2[k,m]*X[m,t-2]

X_1 = np.array([X[0,i] for i in range(N)])
X_2 = np.array([X[1,i] for i in range(N)])
X_3 = np.array([X[2,i] for i in range(N)])
X_4 = np.array([X[3,i] for i in range(N)])
X_5 = np.array([X[4,i] for i in range(N)])

len(X_1)

df = pd.DataFrame([X_1, X_2, X_3, X_4, X_5]).T
n,d = df.shape
df

X_1 = np.array([X[0,i] for i in range(N)])
X_2 = np.array([X[1,i] for i in range(N)])
X_3 = np.array([X[2,i] for i in range(N)])
X_4 = np.array([X[3,i] for i in range(N)])
X_5 = np.array([X[4,i] for i in range(N)])

fig, axs = plt.subplots(1,1,figsize=(12,12)) # Create a figure and an axes. 
ax1=plt.subplot(3,2,(1,2))
ax1.plot(range(N),X_1,**{'marker': 'x'},label='$X^1_t$')
ax1.plot(range(N),X_2,**{'marker': 'o'},label='$X^2_t$')
ax1.plot(range(N),X_3,**{'marker': '*'},label='$X^3_t$')

ax1.set_xlabel('Time $t$') # Add an x-label to the axes. 
ax1.set_ylabel('Process $\mathbf{X}_t$') # Add a y-label to the axes. 
ax1.set_title("VAR($p$) process") # Add a title to the axes.

def get_Cp(mat, p):
  # t is the total # of time steps, and p for # of variables.
  Xbar = np.zeros(d)
  for i in range(d):
    Xbar[i] = np.mean(mat[: , i])

  C = np.zeros((d, d))
  for i in range(n-p):
    Z0 = np.transpose(mat[i, :] - Xbar) # column vector
    Z1 = mat[i+p, :] - Xbar # row vector
    C = C + np.matmul(Z0, Z1)

  C = C/n
  return C

get_Cp(np.matrix(df), 0)

get_Cp(np.matrix(df), 1)

get_Cp(np.matrix(df), 2)

get_Cp(np.matrix(df), 3)

#A=
#B=
difference_array = np.subtract(A, B)
squared_array = np.square(difference_array)
mse = squared_array.mean()

print(mse)

df = pd.DataFrame([X_1, X_2, X_3, X_4, X_5]).T
df.to_excel('VAR_higher_order.xlsx', index=False)
df.to_excel(excel_writer = 'C:/Users/1vspe/Documents/VAR_higher_order.xlsx')


# -*- coding: utf-8 -*-
"""VAR(1)_X100_Sim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S0AGoSVVY_L1Tw9KPqF_H5qk8vxHkOzv
"""

# Catherine Donner and Hung Tran

import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
from scipy import stats

#df = pd.read_excel("https://archive.ics.uci.edu/ml/machine-learning-databases/00247/data_akbilgic.xlsx", header=1)
#df.drop(df.index[[0]])

#X_raw = pd.read_excel("https://archive.ics.uci.edu/ml/machine-learning-databases/00247/data_akbilgic.xlsx", header=1)
#X= X_raw.reindex(columns = ["BOVESPA", "SP", "FTSE", "DAX", "EU", "EM",
                              "ISE.1", "NIKKEI"])
#X.head() # display first 5 rows

N = 100

M = N // 2
p = 1
q = 0
d = 3

alpha0=np.identity(d)
alpha1=np.array([[-1/2,1/3,-1/6],[0,1/2,-4/5],[0,0,-.9]])
alpha1

s = (d,d)
alpha2 = np.zeros(s)
beta= np.array([[.01,0,0],[0,.01,0],[0,0,.01]]) 
beta

beta*beta.T

X=np.zeros((d,N)) 
xi=np.empty((d,N))

pp = np.random.normal(0,1,10)
pp = np.random.standard_normal() 
np.random.seed(4)
for k in range(N):
    for m in range(d):
        xi[m,k]= np.random.standard_normal()

pp

xi

def get_Cp(mat, p):
  # t is the total # of time steps, and p for # of variables.
  Xbar = np.zeros(d)
  for i in range(d):
    Xbar[i] = np.mean(mat[: , i])

  C = np.zeros((d, d))
  for i in range(n-p):
    Z0 = np.transpose(mat[i, :] - Xbar) # column vector
    Z1 = mat[i+p, :] - Xbar # row vector
    C = C + np.matmul(Z0, Z1)

  C = C/n
  return C

n,d = X.shape # X is an n x d dataframe (can be turned into matrix)

get_Cp(np.matrix(X),2)

for t in range(N):
    for k in range(d):
        for m in range(d):
            X[k,t]=X[k,t]+beta[k,m]*xi[m,t]
            if t > 0: 
                X[k,t]=X[k,t]-alpha1[k,m]*X[m,t-1]
            if t > 1:
                X[k,t]=X[k,t]-alpha2[k,m]*X[m,t-2]

X_1 = np.array([X[0,3] for i in range(100)])
X_2 = np.array([X[0,3] for i in range(100)])
X_3 = np.array([X[0,3] for i in range(100)])



H=np.empty((d,d,M))
for m in range(d):
    for n in range(d):
        H[m,n,0]=beta[m,n]
for k in range(M):   
    for m in range(d):
        for n in range(d):
            if k > 0:
                H[m,n,k]=0
                for s in range(d):
                    H[m,n,k]=H[m,n,k]-alpha1[m,s]*H[s,n,k-1]
            if k > 1: 
                for s in range(d):
                    H[m,n,k]=H[m,n,k]-alpha2[m,s]*H[s,n,k-2]

c=np.empty((d,d,M))
for s in range(M):
    hm=M-s
    for m in range(d):
        for n in range(d):
            c[m,n,s]=0
            for k in range(hm):
                for v in range(d):
                    c[m,n,s]=c[m,n,s]+H[m,v,k+s]*H[n,v,k]

L = 100

f=np.empty((d,d,L),dtype=complex)
for om in range(L):
    H1=np.zeros((d,d),dtype=complex)
    for ll in range(2*M):
        l=ll-M
        H2=np.zeros((d,d),dtype=complex)
        for k in range(M):
            if (l+k >= 0) and (l+k < M):
                for m in range(d):                
                    for n in range(d):
                        for s in range(d):
                            H2[m,n]=H2[m,n]+H[m,s,l+k]*H[n,s,k]
        for m in range(d):
            for n in range(d):
                H1[m,n]=H1[m,n]+np.exp(-1j*l*om*2*np.pi/L)*H2[m,n]
    for m in range(d):
        for n in range(d):
            f[m,n,om]=(1/(2*np.pi))*H1[m,n]

# Matrices from Jack and Haoyu
import numpy as np

A = np.random.rand(8,8)
K = np.matmul(A,np.transpose(A))
d = int(len(K)/2)
L = np.zeros((2*d,2*d))
D = np.zeros((2*d,2*d))

for j in range(d):
  if j == 0:
    D[0,0] = K[0,0]
  else:
    sum = 0
    for h in range(j):
      sum += L[j,h]*D[h,h]*L[j,h]
    D[j,j] = K[j,j] - sum

  for i in range(j+1,d):
    sum = 0
    for h in range(j):
      sum += L[i,h]*D[h,h]*L[j,h]
    L[i,j] = (K[i,j] - sum)/D[j,j]

  L[d:,j] = K[d:,j]
  for h in range(j):
    L[d:,j] -= D[h,h]*L[j,h]*L[d:,h]
  L[d:,j] = L[d:,j]/D[j,j]

for i in range(int(2*d)):
  L[i,i] = 1
                
D[d:,d:] = np.linalg.inv(np.linalg.inv(K)[d:,d:])

print(K)

print(L)

print(D)

print(np.matmul(L,np.matmul(D,np.transpose(L))))

print(np.zeros((2,1)))

